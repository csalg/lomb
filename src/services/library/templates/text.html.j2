<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.8.2/css/bulma.min.css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            border: 0;
            padding: 0
        }
        :root {
            --looked-up-bg: hsla(17, 86%, 69%, 0.11);
            --not-looked-up-bg: hsla(209, 86%, 69%, 0.22);
        }
        .render_newlines{
            white-space: pre-line;
        }
        .container_ {
            display: flex;
        }
        .text-and-support-area {
            width: 60vw;
            height: 100vh;
        }
        .support-area {
            display: flex;
            justify-content: center;
            height: 20vh;
            padding: 1rem 0;
            border-bottom: thin solid black;
            overflow-y: scroll;
        }
        #support {
            width: 30rem;
        }
        .definition {
            width: 40vw;
            height: 100vh;
            border-left: thin solid black;
        }
        .text-area {
            display: flex;
            justify-content: center;
            width: 60vw;
            height: 80vh;
        }
        #text {
            overflow-y: scroll;
            scrollbar-width: none;
            width: 100%;
            display: flex;
            justify-content: center;
        }
        .readable-width {
            max-width: 30rem;
            padding: 0 auto;
        }
        .definition {
            overflow-y: scroll;
            width: 40%;
            padding: 1rem;
        }
        .looked-up {
            background-color: var(--looked-up-bg)
        }
        .not-looked-up {
            background-color: var(--not-looked-up-bg);
        }
        .word-tooltip {
            padding: 1rem;
            background-color: ivory;
        }
        .autocompletion {
            margin: 0;
            position: relative;
            z-index: 99;
            left: 0;
            right: 0;
            padding: 0;
        }
        .autocompletion .autocompletion_item {
            border-bottom: 1px solid #aaa;
            padding: 5px 5px 5px 10px;
            font-weight: 400;
            font-size: 14px;
            cursor: pointer;
        }
        .autocompletion .translation_item {
            display: inline;
            margin-right: 5px;
        }
        .autocompletion .wordtype {
            display: inline;
            color: #aaa;
            margin-left: 5px;
            margin-right: 3px;
            font-weight: 400;
            font-size: 12px;
            font-style: italic;
        }
        .space-under{
            height: 110vh;
        }
    </style>
<body>
    <div class="container_">
        <div class="text-and-support-area">
            <div class="support-area">
                <div class="readable-width" id="support">
                    <div class="support"></div>
                </div>
            </div>
            <div class="text-area">
                <div id="text">
                <div class="readable-width">


            {% for chunk in chunks %}<span data-id="{{loop.index0}}" data-support="{{chunk.support_text|escape}}" class="render_newlines">{{chunk.source_text}}</span>{% endfor %}
                <div class="space-under"></div>
                </div>
                </div>
            </div>
        </div>
    <div class="definition">   </div>
</div>
</body>


<script>
    const URL = "http://192.168.1.41:5000/tracking/"
    const matchesPunctuation = /[^A-Za-zÁÀȦÂÄǞǍĂĀÃÅǺǼǢĆĊĈČĎḌḐḒÉÈĖÊËĚĔĒẼE̊ẸǴĠĜǦĞG̃ĢĤḤáàȧâäǟǎăāãåǻǽǣćċĉčďḍḑḓéèėêëěĕēẽe̊ẹǵġĝǧğg̃ģĥḥÍÌİÎÏǏĬĪĨỊĴĶǨĹĻĽĿḼM̂M̄ʼNŃN̂ṄN̈ŇN̄ÑŅṊÓÒȮȰÔÖȪǑŎŌÕȬŐỌǾƠíìiîïǐĭīĩịĵķǩĺļľŀḽm̂m̄ŉńn̂ṅn̈ňn̄ñņṋóòôȯȱöȫǒŏōõȭőọǿơP̄ŔŘŖŚŜṠŠȘṢŤȚṬṰÚÙÛÜǓŬŪŨŰŮỤẂẀŴẄÝỲŶŸȲỸŹŻŽẒǮp̄ŕřŗśŝṡšşṣťțṭṱúùûüǔŭūũűůụẃẁŵẅýỳŷÿȳỹźżžẓǯßœŒçÇ]/

    const token_dictionaries = [
        {% for chunk in chunks %}
            {{ chunk.token_dictionary }},
        {% endfor %}
    ]

    let clicked_sentence = 0


    const main = () => {
        const observer = create_intersection_observer()
        const chunks = document.querySelectorAll('#text span')
        chunks.forEach(element => {
            element.addEventListener('click', lookup(element));
            element.addEventListener('touchstart', lookup(element));
            observer.observe(element);
        })
        document.addEventListener('mouseup', lookup_word)
    }


    const create_intersection_observer = () => {
        let options = {
        root: document.querySelector('#text'),
        rootMargin: '0px 0px -100%',
        threshold: 0
        }

        return new IntersectionObserver(out_of_view_callback, options);
    }


    const out_of_view_callback = (entries) => {
        if (entries.length > 20){
            return
        }
        entries.forEach((entry) => {
            if (!was_looked_up(entry.target) && !was_not_looked_up(entry.target)){
                const idx = parseInt(entry.target.dataset.id);
                const lemmas = get_lemmas(idx)

                dispatch({
                    type: 'SENTENCE_EXPOSURE',
                    context: lemmas,
                    payload: 'NO_LOOKUP'
                })

                entry.target.classList.add('not-looked-up')
            }
        })
    }

    const get_lemmas = idx => {
        const token_dictionary = token_dictionaries[idx];
        return Object.values(token_dictionary);
    }


    const was_looked_up = element => element.classList.contains('looked-up')


    const was_not_looked_up = element => element.classList.contains('not-looked-up')


    const lookup = element => _ => {
        change_support_text(element.dataset.support)
        const idx = parseInt(element.dataset.id);
        clicked_sentence = idx;

        if (!was_looked_up(element) && !was_not_looked_up(element)){
            const lemmas = get_lemmas(idx)
            element.classList.add("looked-up")

            dispatch({
                type: 'SENTENCE_EXPOSURE',
                context: lemmas,
                payload: 'LOOKUP'
            })
        }
    }


    const change_support_text = new_text => {
        const support_text_element = document.querySelector('.support')
        support_text_element.innerHTML = new_text;

        // console.log(new_text)
    }


    const lookup_word = e => {
        const selection = window.getSelection();      // get the selection then
        if (selection.toString().length < 2  || matchesPunctuation.test(selection.toString())){
            return
        }
        const lemma = token_to_lemma(clicked_sentence, selection.toString())
        if (lemma) update_suggestion(lemma);
    }


    const token_to_lemma = (sentence_idx, token) => {
        const token_dictionary = token_dictionaries[sentence_idx];
        return token_dictionary[token];
    }


    async function dispatch(data){
        console.log(JSON.stringify(data))
        const response = await fetch(URL,
        {
            method: "POST",
            mode: 'cors',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        })

        return response
    }


    async function update_suggestion(new_word){
        const URL = `http://192.168.1.41:5001/http://www.linguee.com/english-german/search?qe=${encodeURI(new_word)}&source=auto&cw=714&ch=398`;
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
            // Typical action to be performed when the document is ready:
            document.querySelector(".definition").innerHTML = xhttp.responseText;

            dispatch({
                type: 'WORD_EXPOSURE',
                context: [new_word],
                payload: 'LOOKUP'
            })
        }
        };
        xhttp.open("GET", URL, true);
        xhttp.send();
    }

    main()


</script>
</html>